<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,viewport-fit=cover">
<title>贪吃蛇 · Snake</title>
<style>
  :root{
    --bg: radial-gradient(1600px 1000px at 10% -10%, #e0f2ff 0%, #f7f7fb 28%, #f5f5ff 55%, #f9fafb 100%);
    --panel: rgba(255,255,255,.78);
    --panel-blur: blur(10px);
    --card: #ffffffcc;
    --text: #0f172a;
    --muted:#64748b;
    --brand: #5b8eff;
    --brand-2:#7c3aed;
    --ok:#10b981;
    --danger:#ef4444;
    --grid:#e9eef5;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  html, body { overflow-x: hidden; }
  body{
    margin:0; color:var(--text); font-family: ui-sans-serif,system-ui,"PingFang SC","Noto Sans CJK SC",Segoe UI,Roboto,Arial;
    background: var(--bg);
  }
  .wrap{max-width:1280px; margin:24px auto; padding:16px}
  header{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin-bottom:16px;}
  h1{font-size:22px; margin:0; letter-spacing:.4px}
  .panel{
    backdrop-filter: var(--panel-blur);
    background: var(--panel);
    border:1px solid #e7ebf3;
    border-radius:20px; padding:14px 16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;
    box-shadow:0 10px 30px rgba(0,0,0,.06);
  }
  .stat{display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:12px; background:#ffffff80; border:1px solid #edf1f6}
  .stat b{font-size:18px}
  .grow{flex:1}
  .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .btn{
    appearance:none; border:1px solid #e5e7eb; background:white; color:#111; padding:12px 18px; border-radius:12px; font-weight:800; cursor:pointer;
    transition:.2s; box-shadow:0 2px 0 rgba(17,24,39,.04);
  }
  .btn:hover{transform:translateY(-1px); box-shadow:0 6px 16px rgba(17,24,39,.09)}
  .btn.brand{background: linear-gradient(135deg,var(--brand),var(--brand-2)); color:white; border-color:transparent; font-size:16px}
  .btn.red{background:linear-gradient(135deg,#ff7676,#ff4b4b); color:white; border-color:transparent}
  .btn:disabled{opacity:.6; cursor:not-allowed; transform:none; box-shadow:none}
  .seg{display:flex; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; background:white}
  .seg button{border:0; padding:8px 12px; font-weight:600; background:transparent; cursor:pointer}
  .seg button.active{background:#111; color:#fff}
  .range{display:flex; align-items:center; gap:8px}
  .range input[type=range]{accent-color:#4f46e5}
  .switch{display:inline-flex; align-items:center; gap:8px; font-weight:600}
  .switch input{width:42px; height:22px}
  .grid{display:grid; grid-template-columns: 2fr 1fr; gap:16px; align-items:start; margin-top:14px;}
  @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }
  .left{
    background: #ffffffb3; border:1px solid #e7ebf3; border-radius:20px; padding:14px; backdrop-filter: var(--panel-blur);
    box-shadow:0 10px 30px rgba(0,0,0,.06);
  }
  .canvas-wrap{position:relative; border-radius:16px; overflow:hidden; border:1px solid #e6eaf2}
  .board-sizing{
    height: var(--board-h, auto);
    height: min(60svh, 100vw);
    width: min(100%, 100vmin);
    max-width: 100%;
    aspect-ratio: 1 / 1;
  }
  canvas{display:block; width:100%; height:100%; background: #fbfcfe}
  .grid-overlay{
    position:absolute; inset:0; background-image:
      linear-gradient(to right, var(--grid) 1px, transparent 1px),
      linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
    background-size: calc(100%/var(--grid-cnt,21)) 100%, 100% calc(100%/var(--grid-cnt,21));
    pointer-events:none; opacity:.8
  }
  .right{display:flex; flex-direction:column; gap:12px}
  .card{background:var(--card); border:1px solid #e7ebf3; border-radius:16px; padding:12px}
  .mobile-only{display:none;}
  @media (hover: none) and (pointer: coarse){
    .mobile-only{display:block;}
  }
  .dpad{
    width:200px; aspect-ratio:1/1; border-radius:18px; border:1px solid #e7ebf3; background:#fff; position:relative; margin:auto;
    display:grid; place-items:center; box-shadow:inset 0 10px 20px rgba(0,0,0,.04)
  }
  .dpad button{
    position:absolute; width:62px; height:62px; border-radius:14px; border:1px solid #e5e7eb; background:#f8fafc; font-weight:800; cursor:pointer; transition:.1s
  }
  .dpad button:active{transform:scale(.97)}
  .dpad .up{top:10px}
  .dpad .down{bottom:10px}
  .dpad .left{left:10px}
  .dpad .right{right:10px}
  footer{margin-top:16px; color:#8a93a6; font-size:12px; display:flex; gap:8px; align-items:center}
  .dot{width:6px; height:6px; border-radius:50%; background:#d1d5db}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div><h1>贪吃蛇</h1></div>
    </header>

    <div class="panel" style="justify-content:space-between">
      <div class="range" title="游戏速度（毫秒间隔，越小越快）">
        <label>速度</label>
        <input id="speed" type="range" min="60" max="260" value="140" step="10">
        <span style="color:var(--muted);font-size:13px"><span id="speedVal">140</span> ms / 步</span>
      </div>
      <div class="seg" aria-label="边界模式">
        <button data-wall="true" class="active" id="wallOn">撞墙即死</button>
        <button data-wall="false" id="wallOff">穿墙循环</button>
      </div>
      <label class="switch" title="音效（WebAudio）">
        <input id="sound" type="checkbox" checked> 声音
      </label>
      <label class="switch" title="显示网格">
        <input id="gridToggle" type="checkbox" checked> 网格
      </label>
    </div>

    <div class="grid">
      <div class="left">
        <div class="canvas-wrap" id="canvasWrap">
          <div class="board-sizing">
            <canvas id="board"></canvas>
          </div>
          <div id="gridOverlay" class="grid-overlay"></div>
        </div>
      </div>

      <div class="panel">
        <div class="stat" title="当前得分"><span>分数</span><b id="score">0</b></div>
        <div class="stat" title="本地最高分（仅本机）"><span>最高</span><b id="best">0</b></div>
        <div class="grow"></div>
        <div class="controls">
          <button id="btnStart" class="btn brand">开始</button>
          <button id="btnPause" class="btn" disabled>暂停</button>
          <button id="btnRestart" class="btn red">重开</button>
        </div>
      </div>
      
      <div class="right">
        <div class="card mobile-only" aria-hidden="true">
          <h3>触控方向键</h3>
          <div class="dpad" aria-label="虚拟方向键">
            <button class="up">↑</button>
            <button class="down">↓</button>
            <button class="left">←</button>
            <button class="right">→</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  /** ======= 可调参数 ======= */
  let   GRID = 21;                // 网格边长（格子数）
  let   GAME_SPEED_MS = 140;      // 初始速度（毫秒/步）
  const SNAKE_COLOR_A = "#5b8eff";
  const SNAKE_COLOR_B = "#7c3aed";
  const FOOD_COLOR    = "#7c3aed";
  const BG_COLOR      = "#fbfcfe";
  let   CELL = 30;                // 运行时根据画布尺寸重算（浮点）
  /** ======================= */

  // 画布 & 上下文（HiDPI 适配）
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const canvasWrap = document.getElementById('canvasWrap');

  // UI
  const elScore = document.getElementById('score');
  const elBest  = document.getElementById('best');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const speed = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const segWall = [document.getElementById('wallOn'), document.getElementById('wallOff')];
  const sound = document.getElementById('sound');
  const gridToggle = document.getElementById('gridToggle');
  const gridOverlay = document.getElementById('gridOverlay');

  // 触控方向键（移动端可见）
  const dpad = {
    up: document.querySelector('.dpad .up'),
    down: document.querySelector('.dpad .down'),
    left: document.querySelector('.dpad .left'),
    right: document.querySelector('.dpad .right')
  };

  // 本地最高分
  const BEST_KEY = 'snake_best_v1';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  elBest.textContent = best;

  // 游戏状态
  let growPerFood = 1;     // 固定增长 1
  let wallDie = true;      // true=撞墙即死；false=穿墙循环
  let running = false;
  let pendingDir = null;

  // 声音（WebAudio）
  let AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function beep(freq = 660, duration = 0.06, type = 'square', gain=0.03){
    if(!sound.checked) return;
    if(!AudioCtx) return;
    if(!audioCtx) audioCtx = new AudioCtx();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    o.start(now); o.stop(now + duration);
  }

  // 工具
  function randInt(min, max){ return (Math.random() * (max - min + 1) | 0) + min; }
  function eq(a,b){ return a.x===b.x && a.y===b.y; }

  // 初始化蛇与食物
  let snake, dir, food, score, growLeft;

  function reset(){
    score = 0; elScore.textContent = score;
    const mid = (GRID/2 | 0);
    snake = [{x:mid, y:mid}, {x:mid-1,y:mid}, {x:mid-2,y:mid}];
    dir = {x:1,y:0};
    pendingDir = null;
    growLeft = 0;
    placeFood();
    draw(true);
  }

  function placeFood(){
    // 最多尝试 GRID*GRID 次以防极端占满
    for (let i=0;i<GRID*GRID;i++){
      const f = {x: randInt(0,GRID-1), y: randInt(0,GRID-1)};
      if(!snake.some(p => eq(p,f))){ food = f; return; }
    }
    // 兜底：全局扫描
    outer: for (let y=0;y<GRID;y++){
      for (let x=0;x<GRID;x++){
        const f = {x,y}; if(!snake.some(p=>eq(p,f))){ food=f; break outer; }
      }
    }
  }

  // 自适应 & HiDPI：根据真实展示尺寸设置画布像素
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // 物理像素尺寸
    canvas.width  = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);

    // 在“CSS 像素坐标系”绘制
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // FIX: 用“精确浮点格子宽度”，保证画面与 overlay 网格对齐
    const side = Math.min(rect.width, rect.height);
    CELL = side / GRID; // ← 不取整

    // 让 overlay 使用相同网格数
    canvasWrap.style.setProperty('--grid-cnt', GRID);

    if (snake && food) draw(true);
  }

  // 计算首屏可用高度并写入 --board-h
  function fitBoardToViewport() {
    const header = document.querySelector('header');
    const topPanel = document.querySelector('header + .panel');
    const boardBox = document.querySelector('.board-sizing');

    const innerH = window.innerHeight;
    const reserve =
      (header?.offsetHeight || 0) +
      (topPanel?.offsetHeight || 0) +
      24 + 14 + 16;
    const avail = Math.max(200, innerH - reserve);
    const ideal = Math.min(avail, window.innerWidth);
    boardBox.style.setProperty('--board-h', ideal + 'px');

    resizeCanvas();
  }

  // 绘制
  function draw(clear=false){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    if(clear){
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0,0,w,h);
    } else {
      ctx.fillStyle = "#ffffff";
      ctx.globalAlpha = .9;
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
    }
    if (!snake || !food) return;

    // 食物
    const foodX = food.x*CELL + CELL/2, foodY = food.y*CELL + CELL/2, r = CELL*0.32;
    ctx.save();
    ctx.translate(foodX, foodY);
    ctx.beginPath();
    const grad = ctx.createRadialGradient(0,0, r*0.2, 0,0, r);
    grad.addColorStop(0, FOOD_COLOR);
    grad.addColorStop(1, "#c4b5fd");
    ctx.fillStyle = grad;
    ctx.shadowColor = "rgba(124,58,237,.25)";
    ctx.shadowBlur = 18;
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // 蛇
    for(let i=0; i<snake.length; i++){
      const {x,y} = snake[i];
      const px = x*CELL, py = y*CELL;
      const radius = Math.max(6, CELL*0.28);
      const g = ctx.createLinearGradient(px,py, px+CELL, py+CELL);
      g.addColorStop(0, SNAKE_COLOR_A);
      g.addColorStop(1, SNAKE_COLOR_B);
      ctx.fillStyle = g;
      ctx.strokeStyle = "rgba(0,0,0,.06)";
      ctx.lineWidth = 1;
      roundRect(ctx, px+1.5, py+1.5, CELL-3, CELL-3, radius);
      ctx.fill();
      ctx.stroke();

      if(i===0){
        // 高光
        ctx.save();
        ctx.globalAlpha = .25;
        ctx.fillStyle = "#fff";
        roundRect(ctx, px+CELL*0.12, py+CELL*0.12, CELL*0.66, CELL*0.66, Math.min(10, CELL*0.33));
        ctx.fill();
        ctx.restore();

        // 眼睛
        const ex = px + CELL/2 + (dir.x*4);
        const ey = py + CELL/2 + (dir.y*4);
        const er = Math.max(2, CELL*0.08);
        const off = Math.max(3, CELL*0.16);
        ctx.fillStyle = "#0f172a";
        ctx.beginPath(); ctx.arc(ex-off, ey-off, er, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(ex+off, ey+off, er, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // 前进一步
  function step(){
    if(pendingDir){
      if(!(dir.x + pendingDir.x === 0 && dir.y + pendingDir.y === 0)){
        dir = pendingDir;
      }
      pendingDir = null;
    }

    const head = snake[0];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    if(wallDie){
      if(nx<0 || nx>=GRID || ny<0 || ny>=GRID) return gameOver();
    } else {
      if(nx<0) nx = GRID-1;
      if(nx>=GRID) nx = 0;
      if(ny<0) ny = GRID-1;
      if(ny>=GRID) ny = 0;
    }

    const newHead = {x:nx, y:ny};

    // FIX: 自撞判定忽略“本轮会被去掉的尾巴”
    // 如果不会增长（growLeft===0），尾巴会在本轮 pop 掉，因此不应算碰撞
    const ignoreTail = (growLeft === 0);
    const bodyToCheckLen = snake.length - (ignoreTail ? 1 : 0);
    for (let i=0; i<bodyToCheckLen; i++){
      if (eq(snake[i], newHead)) return gameOver();
    }

    snake.unshift(newHead);

    if(eq(newHead, food)){
      score += 10; elScore.textContent = score;
      growLeft += Math.max(1, growPerFood);
      placeFood();
      beep(820, .06, 'sine', 0.05);
    }

    if(growLeft > 0){
      growLeft--;
    } else {
      snake.pop();
    }

    draw();
  }

  // 基于 rAF 的定时（累积器）
  let lastTs = 0, acc = 0, rafId = 0;
  function loop(ts){
    if(!running){ return; }
    if(!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;
    acc += dt;

    const maxSteps = 5;
    let steps = 0;
    while(acc >= GAME_SPEED_MS && steps < maxSteps){
      step();
      acc -= GAME_SPEED_MS;
      steps++;
    }

    rafId = requestAnimationFrame(loop);
  }

  function start(){
    if(running) return;
    running = true;
    btnStart.disabled = true; btnPause.disabled = false;
    lastTs = 0; acc = 0;
    rafId = requestAnimationFrame(loop);
  }

  function pause(){
    if(!running) return;
    running = false;
    btnStart.disabled = false; btnPause.disabled = true;
    cancelAnimationFrame(rafId);
  }

  function restart(){
    pause(); reset(); // 不自动开始
  }

  function gameOver(){
    pause();
    beep(200, .12, 'triangle', 0.06);
    if(score > best){
      best = score;
      localStorage.setItem(BEST_KEY, String(best));
      elBest.textContent = best;
    }
    ctx.fillStyle = "rgba(15,23,42,.72)";
    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    ctx.fillStyle = "#fff";
    ctx.font = "700 32px ui-sans-serif,system-ui";
    ctx.textAlign = "center";
    ctx.fillText("游戏结束", canvas.clientWidth/2, canvas.clientHeight/2 - 10);
    ctx.font = "600 16px ui-sans-serif,system-ui";
    ctx.fillText("按 R 重开，或点击“重开”", canvas.clientWidth/2, canvas.clientHeight/2 + 24);
  }

  // 事件：按钮
  btnStart.addEventListener('click', start);
  btnPause.addEventListener('click', pause);
  btnRestart.addEventListener('click', restart);

  // 事件：边界
  segWall.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      segWall.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      wallDie = btn.dataset.wall === 'true';
      beep(420,.04,'sine',0.03);
    });
  });

  // 事件：网格显示
  gridToggle.addEventListener('change', ()=>{
    gridOverlay.style.display = gridToggle.checked ? 'block' : 'none';
  });

  // 事件：速度滑块
  speed.addEventListener('input', ()=>{
    speedVal.textContent = speed.value;
    GAME_SPEED_MS = Number(speed.value);
  });

  // 键盘
  const key2dir = {
    ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
    w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0},
    W:{x:0,y:-1}, S:{x:0,y:1}, A:{x:-1,y:0}, D:{x:1,y:0},
  };
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){ e.preventDefault(); running?pause():start(); return; }
    if(e.key === 'r' || e.key === 'R'){ restart(); return; }
    const nd = key2dir[e.key];
    if(nd){
      e.preventDefault();
      pendingDir = nd;
      if(!running) start();
    }
  });

  // 触控方向键
  dpad.up?.addEventListener('click', ()=>{ pendingDir = {x:0,y:-1}; if(!running) start(); });
  dpad.down?.addEventListener('click', ()=>{ pendingDir = {x:0,y:1};  if(!running) start(); });
  dpad.left?.addEventListener('click', ()=>{ pendingDir = {x:-1,y:0}; if(!running) start(); });
  dpad.right?.addEventListener('click', ()=>{ pendingDir = {x:1,y:0};  if(!running) start(); });

  // 音频解锁（首次交互）
  ['click','touchstart','keydown'].forEach(ev=>{
    window.addEventListener(ev, ()=>{ if(AudioCtx && !audioCtx && sound.checked){ audioCtx = new AudioCtx(); } }, {once:true});
  });

  // 启动顺序
  gridOverlay.style.display = gridToggle.checked ? 'block' : 'none';
  window.addEventListener('resize', fitBoardToViewport);
  window.addEventListener('orientationchange', fitBoardToViewport);

  reset();
  fitBoardToViewport();
})();
</script>
</body>
</html>
