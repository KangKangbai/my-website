<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<title>小时制学习法 · 40/20</title>
<meta name="description" content="40分钟学习 + 20分钟休息 的极简番茄页面，自动循环，切换有提示音。" />
<style>
  :root{
    --bg:#f6f7fb; --card:#ffffff; --text:#0f172a; --muted:#64748b;
    --brand:#0b57d0; --border:#e5e7eb; --shadow:0 10px 30px rgba(0,0,0,.06); --radius:18px;
  }
  @media (prefers-color-scheme: dark){
    :root{ --bg:#0b1020; --card:#0f172a; --text:#e5e7eb; --muted:#94a3b8; --border:#1f2937; --shadow:0 10px 30px rgba(0,0,0,.45); }
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Noto Sans SC",Arial;
    background: radial-gradient(1200px 600px at 10% -10%, rgba(11,87,208,.08), transparent 60%), var(--bg);
    color:var(--text); display:grid; place-items:center;
  }
  .wrap{
    width:min(680px,92vw); background:var(--card); border:1px solid var(--border);
    border-radius:var(--radius); box-shadow:var(--shadow); padding:24px 22px; text-align:center;
  }
  .stage{
    display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border:1px solid var(--border);
    border-radius:999px; font-weight:700;
  }
  .badge-study{ border-color:#bfdbfe; color:#1d4ed8; }
  .badge-break{ border-color:#fde68a; color:#b45309; }
  .timer{ font-weight:800; font-size:clamp(44px, 8vw, 76px); letter-spacing:1px; margin:14px 0 6px; }
  .cycle{ color:var(--muted); font-size:14px; margin-bottom:18px; }
  .progress{ height:12px; background:#eef2ff; border-radius:999px; overflow:hidden; border:1px solid var(--border); }
  .bar{ height:100%; width:0%; background:linear-gradient(90deg, var(--brand), #7c3aed); transition:width .2s ease; }
  .controls{ margin-top:18px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }
  .btn{
    appearance:none; border:1px solid var(--brand); background:var(--brand); color:#fff;
    padding:10px 16px; border-radius:12px; font-weight:800; cursor:pointer; transition:.12s;
  }
  #btnStart{ font-size:18px; padding:14px 26px; border-radius:14px; }
  .btn.ghost{ background:transparent; color:var(--text); border-color:var(--border); }
  .btn:hover{ transform:translateY(-1px); }
  footer{ margin-top:12px; color:var(--muted); font-size:12px }
</style>
</head>
<body>
  <main class="wrap" aria-label="40-20 学习计时器">
    <div id="stage" class="stage badge-study" role="status" aria-live="polite">学习中</div>
    <div id="time" class="timer" aria-label="倒计时">40:00</div>
    <div class="cycle" id="cycleInfo">第 1 轮 · 学习</div>

    <div class="progress" aria-label="本阶段进度">
      <div id="bar" class="bar"></div>
    </div>

    <div class="controls">
      <button id="btnStart" class="btn">开始</button>
      <button id="btnReset" class="btn ghost" disabled>重置</button>
    </div>

    <footer>本地运行 · 切后台也会按真实时间推进 · 部分移动端需首次点击后才允许播放提示音</footer>
  </main>

<script>
(() => {
  // ===== 常量 =====
  const STUDY_MIN = 40;
  const BREAK_MIN = 20;
  const STUDY_MS  = STUDY_MIN * 60 * 1000;
  const BREAK_MS  = BREAK_MIN * 60 * 1000;

  // ===== 状态 =====
  let phase = 'study';           // 'study' | 'break'
  let remaining = STUDY_MIN*60;  // seconds（仅用于 UI 展示）
  let endAt = null;              // 当前阶段的目标时间戳（毫秒）
  let running = false;
  let cycle = 1;

  // 定时器句柄
  let deadlineTimer = null;      // 在 endAt 到达时触发切换
  let heartbeat = null;          // 每秒一次，后台也会被动触发，用于“追赶进度”
  let rafId = null;              // 前台的平滑 UI 更新

  // ===== UI =====
  const elStage = document.getElementById('stage');
  const elTime  = document.getElementById('time');
  const elBar   = document.getElementById('bar');
  const elCycle = document.getElementById('cycleInfo');
  const btnStart= document.getElementById('btnStart');
  const btnReset= document.getElementById('btnReset');

  // ===== 声音（WebAudio）=====
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  const unlockAudio = () => { if(AudioCtx && !audioCtx) audioCtx = new AudioCtx(); };

  function beepOnce({freq=1200, duration=0.12, type='square', gain=0.08, when=0}={}){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, audioCtx.currentTime + when);
    g.gain.setValueAtTime(0, audioCtx.currentTime + when);
    g.gain.linearRampToValueAtTime(gain, audioCtx.currentTime + when + 0.005);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + when + duration);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(audioCtx.currentTime + when);
    o.stop(audioCtx.currentTime + when + duration);
  }
  function beepSeries(){
    if(!audioCtx) return;
    for(let i=0;i<5;i++){ beepOnce({when:i}); }
    if(navigator.vibrate){
      try{ navigator.vibrate([120, 880, 120, 880, 120, 880, 120, 880, 120]); }catch(e){}
    }
  }
  async function safeBeepSeries(){
    try{
      if(!audioCtx) return;
      if(audioCtx.state === 'suspended'){
        // 在用户手势触发过后，这里可以顺利恢复
        await audioCtx.resume();
      }
      beepSeries();
    }catch(e){}
  }
  ['click','keydown','touchstart'].forEach(ev => window.addEventListener(ev, () => {
    unlockAudio();
    // 一些浏览器需要在手势内显式 resume
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  }, {once:true}));

  // ===== Wake Lock（防熄屏）=====
  let wakeLock = null;
  async function requestWakeLock(){
    try{
      if('wakeLock' in navigator && !wakeLock){
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener?.('release', () => { wakeLock = null; });
      }
    }catch(e){
      // 失败就算了（不支持/系统策略），仍可靠“唤醒后追赶”
      wakeLock = null;
    }
  }
  async function releaseWakeLock(){
    try{ await wakeLock?.release(); }catch(e){}
    wakeLock = null;
  }

  // ===== 工具 =====
  const fmt = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
  const phaseSeconds = p => (p==='study'?STUDY_MIN:BREAK_MIN)*60;
  const phaseMs      = p => (p==='study'?STUDY_MS:BREAK_MS);
  const phaseLabel   = p => p==='study' ? '学习中' : '休息中';

  function setPhase(p, playTone = true){
    phase = p;
    const totalMs = phaseMs(p);
    remaining = phaseSeconds(p);
    endAt = Date.now() + totalMs;      // 绝对时间作为“真时钟”
    elStage.textContent = phaseLabel(p);
    elStage.className = 'stage ' + (p==='study' ? 'badge-study' : 'badge-break');
    elCycle.textContent = `第 ${cycle} 轮 · ${p==='study' ? '学习' : '休息'}`;

    scheduleDeadlineTimer();

    if(playTone) safeBeepSeries(); // 关键：发声前确保 resume

    updateUI(); // 立即刷新
  }

  function updateUI(){
    const now = Date.now();
    remaining = Math.max(0, Math.ceil((endAt - now)/1000));
    elTime.textContent = fmt(remaining);
    const total = phaseSeconds(phase);
    const pct = Math.min(100, Math.max(0, (1 - remaining/total)*100));
    elBar.style.width = pct.toFixed(2) + '%';
  }

  // 切换阶段（被 deadlineTimer 或心跳/前台检测触发）
  function onPhaseEnd(playTone = true){
    if(phase === 'study'){
      setPhase('break', playTone);
    }else{
      cycle++;
      setPhase('study', playTone);
    }
  }

  // **修复版**：若越过多个阶段，一次性精确追赶到“当前真实阶段”
  function catchUpIfNeeded(){
    if(!running || endAt==null) return;
    const now = Date.now();
    if(now < endAt) return;

    // 我们从“当前阶段的结束点 endAt”开始，不断推进边界直到覆盖 now
    let p = phase;       // 从当前阶段开始
    let t = endAt;       // t 是 p 阶段的结束时间
    let crosses = 0;     // 穿越的边界数量
    let incCycles = 0;   // 需要增加的轮数（每次 break->study +1）

    let guard = 64; // 最多跨 64 个边界（> 24 小时）
    while(now >= t && guard-- > 0){
      // 跨过一个边界：进入下一个阶段
      p = (p === 'study') ? 'break' : 'study';
      if(p === 'study') incCycles++;      // 完成了一轮休息->学习
      t += phaseMs(p);                    // 新阶段的结束时间
      crosses++;
    }

    if(crosses > 0){
      // 一次性更新全局状态（避免在循环中反复定时/响铃）
      phase = p;
      endAt = t;
      cycle += incCycles;

      elStage.textContent = phaseLabel(phase);
      elStage.className = 'stage ' + (phase==='study' ? 'badge-study' : 'badge-break');
      elCycle.textContent = `第 ${cycle} 轮 · ${phase==='study' ? '学习' : '休息'}`;

      scheduleDeadlineTimer();
      safeBeepSeries(); // 只对“最终到达的当前阶段”响一次
      updateUI();
    }
  }

  // 到期切换的单次定时器
  function scheduleDeadlineTimer(){
    if(deadlineTimer) { clearTimeout(deadlineTimer); deadlineTimer = null; }
    const delay = Math.max(0, endAt - Date.now());
    deadlineTimer = setTimeout(() => {
      // 先看是否跨了多个边界（例如后台/系统休眠）
      const oldPhase = phase;
      catchUpIfNeeded();
      // 若正好只跨一个边界，仍需切换一次
      if(oldPhase === phase) onPhaseEnd(true);
    }, delay + 20); // +20ms 容差
  }

  // 前台平滑刷新（rAF），仅负责 UI；阶段切换不依赖 rAF
  function loop(){
    if(!running){ rafId = null; return; }
    updateUI();
    rafId = requestAnimationFrame(loop);
  }

  async function start(){
    if(running) return;
    running = true;
    btnStart.disabled = true;
    btnReset.disabled = false;

    endAt = Date.now() + phaseMs(phase);
    scheduleDeadlineTimer();

    if(!heartbeat){
      heartbeat = setInterval(() => {
        if(!running) return;
        catchUpIfNeeded();
        if(document.hidden) updateUI(); // 后台时也偶尔刷新一次
      }, 1000);
    }
    if(!rafId) rafId = requestAnimationFrame(loop);

    // 尝试防熄屏（支持则防止屏幕关闭，从而尽量不触发系统睡眠）
    requestWakeLock();
  }

  async function reset(){
    running = false;
    cycle = 1;
    if(deadlineTimer){ clearTimeout(deadlineTimer); deadlineTimer = null; }
    if(heartbeat){ clearInterval(heartbeat); heartbeat = null; }
    if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
    setPhase('study', false);
    btnStart.disabled = false;
    btnReset.disabled = true;
    releaseWakeLock();
  }

  // 事件
  btnStart.addEventListener('click', () => { unlockAudio(); start(); });
  btnReset.addEventListener('click', reset);
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){ e.preventDefault(); if(!running) start(); }
    if(e.key === 'r' || e.key === 'R'){ reset(); }
  });

  // 可见性/回到页面时：立刻追赶，并尝试恢复音频和 Wake Lock
  document.addEventListener('visibilitychange', () => {
    if(!running) return;
    catchUpIfNeeded();
    updateUI();
    if(!document.hidden){
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      requestWakeLock();
    }
  });
  window.addEventListener('pageshow', () => {
    if(running){
      catchUpIfNeeded();
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      requestWakeLock();
    }
  });

  // 初始渲染
  setPhase('study', false);
})();
</script>

</body>
</html>
