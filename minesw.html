<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>扫雷 · Mobile Light</title>
  <meta name="description" content="简洁、轻量、适配手机端的扫雷。点按翻开、长按插旗、首击不死。">
  <style>
    :root{
      --bg:#fafafa;
      --card:#ffffff;
      --ink:#1f2937;
      --muted:#6b7280;
      --accent:#2563eb;
      --danger:#dc2626;
      --ok:#16a34a;
      --grid-gap:6px;
      --radius:14px;
      --shadow:0 6px 20px rgba(0,0,0,.08);
      --num1:#2563eb; --num2:#16a34a; --num3:#dc2626; --num4:#7c3aed;
      --num5:#b45309; --num6:#0ea5e9; --num7:#111827; --num8:#6b7280;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Apple Color Emoji,Segoe UI Emoji;
    }
    .wrap{
      padding: max(env(safe-area-inset-top),14px) 14px max(env(safe-area-inset-bottom),14px);
      display:flex; flex-direction:column; gap:12px; min-height:100%;
    }
    header{
      background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow);
      padding:12px 14px; display:flex; align-items:center; justify-content:space-between; gap:10px;
      user-select:none;
    }
    .stat{display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
    .pill{
      background:#f3f4f6; border-radius:999px; padding:4px 10px; font-weight:600; color:var(--ink);
      min-width:72px; text-align:center;
    }
    .pill small{display:block; font-size:12px; color:var(--muted); font-weight:500}
    .controls{display:flex; gap:8px; align-items:center}
    button{
      border:0; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer;
      background:var(--ink); color:white; box-shadow:var(--shadow);
    }
    button.secondary{background:#e5e7eb; color:#111827}
    button:active{transform:translateY(1px)}
    .notice{font-size:12px; color:var(--muted)}
    /* 棋盘容器：高度自适应，避免滚动 */
    .board-wrap{
      background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow);
      padding:12px;
      display:flex; flex-direction:column; gap:10px; min-height:0;
    }
    .board{
      display:grid; gap:var(--grid-gap);
      touch-action:none; /* 阻止双指缩放/滚动干扰手势 */
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      min-height:0; /* 允许在容器内收缩 */
    }
    /* 方块 */
    .cell{
      display:flex; align-items:center; justify-content:center;
      background:#f3f4f6; border-radius:10px; font-weight:800;
      aspect-ratio:1/1; /* 正方形 */
      box-shadow:inset 0 1px 0 rgba(255,255,255,.5), inset 0 -1px 0 rgba(0,0,0,.05);
    }
    .cell.hidden{cursor:pointer}
    .cell.revealed{background:white; box-shadow:inset 0 0 0 1px #e5e7eb}
    .cell.mine.revealed{background:#fee2e2}
    .cell.flag::after{content:"🚩"; font-size:calc(var(--cell-font)*0.9)}
    .cell.mine.revealed::after{content:"💣"; font-size:calc(var(--cell-font)*0.9)}
    .cell.num1{color:var(--num1)} .cell.num2{color:var(--num2)} .cell.num3{color:var(--num3)}
    .cell.num4{color:var(--num4)} .cell.num5{color:var(--num5)} .cell.num6{color:var(--num6)}
    .cell.num7{color:var(--num7)} .cell.num8{color:var(--num8)}
    /* 自适应字号：随格子尺寸变化 */
    :root{ --cell-font: clamp(12px, 2.6vmin, 22px); }
    .board .cell{ font-size:var(--cell-font); }

    footer{color:var(--muted); font-size:12px; text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="stat">
        <div class="pill"><span id="mineLeft">00</span><small>剩余雷</small></div>
        <div class="pill"><span id="timer">00:00</span><small>用时</small></div>
        <div class="pill"><span id="status">准备</span><small>状态</small></div>
      </div>
      <div class="controls">
        <button id="restart">重开</button>
        <button id="mode" class="secondary" title="点按=翻开；长按=插旗">点按翻开 / 长按插旗</button>
      </div>
    </header>

    <div class="board-wrap">
      <div class="notice">提示：首次点击不会踩雷。长按（约0.35秒）插旗；已翻开的数字上点按可“快速开空”。</div>
      <div id="board" class="board" aria-label="扫雷棋盘"></div>
    </div>

    <footer>© Mobile Minesweeper · 纯前端，无数据收集</footer>
  </div>

  <script>
    ;(() => {
      const elBoard   = document.getElementById('board');
      const elTimer   = document.getElementById('timer');
      const elMine    = document.getElementById('mineLeft');
      const elStatus  = document.getElementById('status');
      const btnRestart= document.getElementById('restart');

      // 根据方向/屏幕，选择盘面与雷数（简洁且实际可玩）
      function pickLayout(){
        const portrait = window.matchMedia("(orientation: portrait)").matches;
        // iPhone 13 390x844：纵向使用 16x10，横向 12x18
        return portrait
          ? { rows: 16, cols: 10, mines: 20 }
          : { rows: 12, cols: 18, mines: 40 };
      }

      // 状态
      let R,C,M;                 // 行、列、雷
      let firstClick = true;
      let grid=[], revealed=[], flagged=[], nums=[];
      let gameOver=false, win=false;
      let startAt=null, timerId=null, minesLeft=0;

      function idx(r,c){ return r*C + c }
      function inb(r,c){ return r>=0 && r<R && c>=0 && c<C }
      function neighbours(r,c){
        const res=[];
        for(let dr=-1; dr<=1; dr++)
          for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const nr=r+dr, nc=c+dc;
            if(inb(nr,nc)) res.push([nr,nc]);
          }
        return res;
      }

      function reset(){
        ({rows:R, cols:C, mines:M} = pickLayout());
        firstClick=true; gameOver=false; win=false;
        startAt=null; clearInterval(timerId); elTimer.textContent="00:00";
        minesLeft=M; updateMineLeft();
        grid = new Array(R*C).fill(0); // 1=mine
        revealed = new Array(R*C).fill(false);
        flagged  = new Array(R*C).fill(false);
        nums = new Array(R*C).fill(0);
        elStatus.textContent="准备";
        // 渲染棋盘
        elBoard.style.gridTemplateColumns = `repeat(${C}, 1fr)`;
        elBoard.innerHTML="";
        for(let r=0;r<R;r++){
          for(let c=0;c<C;c++){
            const cell = document.createElement('button');
            cell.className="cell hidden";
            cell.setAttribute('data-r', r);
            cell.setAttribute('data-c', c);
            cell.setAttribute('aria-label', '未翻开');
            cell.addEventListener('click', onClick, {passive:false});
            cell.addEventListener('contextmenu', e=>e.preventDefault());
            setupTouchHandlers(cell);
            elBoard.appendChild(cell);
          }
        }
        // 根据容器高度调整 cell 字号（更稳）
        fitFont();
      }

      function fitFont(){
        // 粗略按容器高度/行数估一份字号，写入 CSS 变量 --cell-font
        const rect = elBoard.getBoundingClientRect();
        const gap = parseFloat(getComputedStyle(elBoard).gap||'6');
        const cellSize = Math.floor((rect.height - gap*(R-1)) / R);
        const px = Math.max(12, Math.min(24, Math.floor(cellSize*0.55)));
        document.documentElement.style.setProperty('--cell-font', px + 'px');
      }

      // 放置地雷，保证首击不死
      function placeMines(safeR, safeC){
        let left=M;
        while(left>0){
          const r = Math.floor(Math.random()*R);
          const c = Math.floor(Math.random()*C);
          if(grid[idx(r,c)]===1) continue;
          // 避免首击 3x3 区域
          if(Math.abs(r-safeR)<=1 && Math.abs(c-safeC)<=1) continue;
          grid[idx(r,c)] = 1;
          left--;
        }
        // 计算数字
        for(let r=0;r<R;r++){
          for(let c=0;c<C;c++){
            const i = idx(r,c);
            if(grid[i]===1){ nums[i]=-1; continue; }
            let n=0;
            for(const [nr,nc] of neighbours(r,c)) if(grid[idx(nr,nc)]===1) n++;
            nums[i]=n;
          }
        }
      }

      function startTimer(){
        if(timerId) return;
        startAt = Date.now();
        timerId = setInterval(()=>{
          const s = Math.floor((Date.now()-startAt)/1000);
          const mm = String(Math.floor(s/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          elTimer.textContent = `${mm}:${ss}`;
        }, 250);
      }

      function updateMineLeft(){
        elMine.textContent = String(minesLeft).padStart(2,'0');
      }

      function reveal(r,c){
        if(gameOver) return;
        const i = idx(r,c);
        if(flagged[i] || revealed[i]) return;

        if(firstClick){
          placeMines(r,c);
          firstClick=false;
          elStatus.textContent="进行中";
          startTimer();
        }

        if(grid[i]===1){
          // 踩雷
          revealed[i]=true;
          renderCell(r,c);
          lose();
          return;
        }
        // BFS 翻空
        const q=[[r,c]];
        while(q.length){
          const [cr,cc]=q.shift();
          const ci=idx(cr,cc);
          if(revealed[ci] || flagged[ci]) continue;
          revealed[ci]=true;
          if(nums[ci]===0){
            for(const [nr,nc] of neighbours(cr,cc)){
              const ni=idx(nr,nc);
              if(!revealed[ni] && !flagged[ni]) q.push([nr,nc]);
            }
          }
        }
        renderRegion();
        checkWin();
      }

      function toggleFlag(r,c){
        if(gameOver) return;
        const i=idx(r,c);
        if(revealed[i]) return;
        if(firstClick){
          // 首次操作如果是长按，也先布雷并启动
          placeMines(r,c);
          firstClick=false;
          elStatus.textContent="进行中";
          startTimer();
        }
        flagged[i]=!flagged[i];
        minesLeft += flagged[i] ? -1 : 1;
        updateMineLeft();
        renderCell(r,c);
        checkWin();
      }

      function chordOpen(r,c){
        // 已翻开的数字格，若周围旗数==数字，则自动翻开其他未翻格
        const i = idx(r,c);
        if(!revealed[i] || nums[i]<=0) return;
        const neigh = neighbours(r,c);
        const flags = neigh.filter(([nr,nc])=>flagged[idx(nr,nc)]).length;
        if(flags !== nums[i]) return;
        for(const [nr,nc] of neigh){
          if(!flagged[idx(nr,nc)] && !revealed[idx(nr,nc)]){
            reveal(nr,nc);
          }
        }
      }

      function lose(){
        gameOver=true; win=false; clearInterval(timerId);
        elStatus.textContent="踩雷";
        // 全部翻开地雷
        for(let r=0;r<R;r++) for(let c=0;c<C;c++){
          const i=idx(r,c);
          if(grid[i]===1){ revealed[i]=true; }
        }
        renderRegion();
      }
      function checkWin(){
        if(gameOver) return;
        // 胜利条件：所有非雷格已翻开
        let opened=0;
        for(let i=0;i<R*C;i++){
          if(revealed[i]) opened++;
        }
        if(opened === R*C - M){
          gameOver=true; win=true; clearInterval(timerId);
          elStatus.textContent="通关";
          // 自动把剩余格标旗
          for(let i=0;i<R*C;i++){
            if(!revealed[i] && !flagged[i]){ flagged[i]=true; minesLeft--; }
          }
          updateMineLeft();
          renderRegion();
        }
      }

      function renderCell(r,c){
        const i=idx(r,c);
        const cell = elBoard.children[i];
        cell.className = 'cell';
        if(!revealed[i]) cell.classList.add('hidden');
        if(flagged[i]) cell.classList.add('flag');
        if(revealed[i] && grid[i]===1) cell.classList.add('mine','revealed');
        if(revealed[i] && grid[i]!==1){
          cell.classList.add('revealed');
          const n = nums[i];
          cell.textContent = n>0 ? n : '';
          if(n>0) cell.classList.add('num'+n);
        }else{
          if(grid[i]!==1) cell.textContent='';
        }
      }
      function renderRegion(){
        for(let r=0;r<R;r++) for(let c=0;c<C;c++) renderCell(r,c);
      }

      // 点击/触摸：短按翻开，长按（≥350ms）插旗；已翻数字上点按尝试“快速开空”
      function onClick(e){
        e.preventDefault();
        const cell=e.currentTarget;
        const r=+cell.dataset.r, c=+cell.dataset.c;
        const i=idx(r,c);
        if(revealed[i] && nums[i]>0){ chordOpen(r,c); return; }
        reveal(r,c);
      }

      function setupTouchHandlers(cell){
        let pressTimer=null, moved=false;
        const start = (e)=>{
          moved=false;
          e.preventDefault();
          pressTimer = setTimeout(()=>{
            const r=+cell.dataset.r, c=+cell.dataset.c;
            toggleFlag(r,c);
            pressTimer=null;
          }, 350); // 长按阈值
        };
        const move = ()=>{
          // 发生滑动则取消长按
          moved=true;
          if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; }
        };
        const end = (e)=>{
          e.preventDefault();
          if(pressTimer){
            clearTimeout(pressTimer); pressTimer=null;
            if(!moved) cell.click(); // 触发短按=翻开
          }
        };
        cell.addEventListener('touchstart', start, {passive:false});
        cell.addEventListener('touchmove', move, {passive:false});
        cell.addEventListener('touchend', end, {passive:false});
        cell.addEventListener('touchcancel', end, {passive:false});
      }

      // 重开、旋转/尺寸变化时自适应
      btnRestart.addEventListener('click', reset);
      window.addEventListener('resize', ()=>{
        const oldR=R, oldC=C;
        const layout = pickLayout();
        if(layout.rows!==oldR || layout.cols!==oldC){
          // 方向/尺寸变化较大：直接重开
          reset();
        }else{
          // 仅字号重算，避免跳局
          setTimeout(fitFont, 50);
        }
      }, {passive:true});

      // 初始化
      reset();
    })();
  </script>
</body>
</html>
