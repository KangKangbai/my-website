<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>æ‰«é›· Â· Mobile Light</title>
  <meta name="description" content="ç®€æ´ã€è½»é‡ã€é€‚é…æ‰‹æœºç«¯çš„æ‰«é›·ã€‚ç‚¹æŒ‰ç¿»å¼€ã€é•¿æŒ‰æ’æ——ã€é¦–å‡»ä¸æ­»ã€‚">
  <style>
    :root{
      --bg:#fafafa;
      --card:#ffffff;
      --ink:#1f2937;
      --muted:#6b7280;
      --accent:#2563eb;
      --danger:#dc2626;
      --ok:#16a34a;
      --grid-gap:6px;
      --radius:14px;
      --shadow:0 6px 20px rgba(0,0,0,.08);
      --num1:#2563eb; --num2:#16a34a; --num3:#dc2626; --num4:#7c3aed;
      --num5:#b45309; --num6:#0ea5e9; --num7:#111827; --num8:#6b7280;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Apple Color Emoji,Segoe UI Emoji;
    }
    .wrap{
      padding: max(env(safe-area-inset-top),14px) 14px max(env(safe-area-inset-bottom),14px);
      display:flex; flex-direction:column; gap:12px; min-height:100%;
    }
    header{
      background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow);
      padding:12px 14px; display:flex; align-items:center; justify-content:space-between; gap:10px;
      user-select:none;
    }
    .stat{display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
    .pill{
      background:#f3f4f6; border-radius:999px; padding:4px 10px; font-weight:600; color:var(--ink);
      min-width:72px; text-align:center;
    }
    .pill small{display:block; font-size:12px; color:var(--muted); font-weight:500}
    .controls{display:flex; gap:8px; align-items:center}
    button{
      border:0; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer;
      background:var(--ink); color:white; box-shadow:var(--shadow);
    }
    button.secondary{background:#e5e7eb; color:#111827}
    button:active{transform:translateY(1px)}
    .notice{font-size:12px; color:var(--muted)}
    /* æ£‹ç›˜å®¹å™¨ï¼šé«˜åº¦è‡ªé€‚åº”ï¼Œé¿å…æ»šåŠ¨ */
    .board-wrap{
      background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow);
      padding:12px;
      display:flex; flex-direction:column; gap:10px; min-height:0;
    }
    .board{
      display:grid; gap:var(--grid-gap);
      touch-action:none; /* é˜»æ­¢åŒæŒ‡ç¼©æ”¾/æ»šåŠ¨å¹²æ‰°æ‰‹åŠ¿ */
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      min-height:0; /* å…è®¸åœ¨å®¹å™¨å†…æ”¶ç¼© */
    }
    /* æ–¹å— */
    .cell{
      display:flex; align-items:center; justify-content:center;
      background:#f3f4f6; border-radius:10px; font-weight:800;
      aspect-ratio:1/1; /* æ­£æ–¹å½¢ */
      box-shadow:inset 0 1px 0 rgba(255,255,255,.5), inset 0 -1px 0 rgba(0,0,0,.05);
    }
    .cell.hidden{cursor:pointer}
    .cell.revealed{background:white; box-shadow:inset 0 0 0 1px #e5e7eb}
    .cell.mine.revealed{background:#fee2e2}
    .cell.flag::after{content:"ğŸš©"; font-size:calc(var(--cell-font)*0.9)}
    .cell.mine.revealed::after{content:"ğŸ’£"; font-size:calc(var(--cell-font)*0.9)}
    .cell.num1{color:var(--num1)} .cell.num2{color:var(--num2)} .cell.num3{color:var(--num3)}
    .cell.num4{color:var(--num4)} .cell.num5{color:var(--num5)} .cell.num6{color:var(--num6)}
    .cell.num7{color:var(--num7)} .cell.num8{color:var(--num8)}
    /* è‡ªé€‚åº”å­—å·ï¼šéšæ ¼å­å°ºå¯¸å˜åŒ– */
    :root{ --cell-font: clamp(12px, 2.6vmin, 22px); }
    .board .cell{ font-size:var(--cell-font); }

    footer{color:var(--muted); font-size:12px; text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="stat">
        <div class="pill"><span id="mineLeft">00</span><small>å‰©ä½™é›·</small></div>
        <div class="pill"><span id="timer">00:00</span><small>ç”¨æ—¶</small></div>
        <div class="pill"><span id="status">å‡†å¤‡</span><small>çŠ¶æ€</small></div>
      </div>
      <div class="controls">
        <button id="restart">é‡å¼€</button>
        <button id="mode" class="secondary" title="ç‚¹æŒ‰=ç¿»å¼€ï¼›é•¿æŒ‰=æ’æ——">ç‚¹æŒ‰ç¿»å¼€ / é•¿æŒ‰æ’æ——</button>
      </div>
    </header>

    <div class="board-wrap">
      <div class="notice">æç¤ºï¼šé¦–æ¬¡ç‚¹å‡»ä¸ä¼šè¸©é›·ã€‚é•¿æŒ‰ï¼ˆçº¦0.35ç§’ï¼‰æ’æ——ï¼›å·²ç¿»å¼€çš„æ•°å­—ä¸Šç‚¹æŒ‰å¯â€œå¿«é€Ÿå¼€ç©ºâ€ã€‚</div>
      <div id="board" class="board" aria-label="æ‰«é›·æ£‹ç›˜"></div>
    </div>

    <footer>Â© Mobile Minesweeper Â· çº¯å‰ç«¯ï¼Œæ— æ•°æ®æ”¶é›†</footer>
  </div>

  <script>
    ;(() => {
      const elBoard   = document.getElementById('board');
      const elTimer   = document.getElementById('timer');
      const elMine    = document.getElementById('mineLeft');
      const elStatus  = document.getElementById('status');
      const btnRestart= document.getElementById('restart');

      // æ ¹æ®æ–¹å‘/å±å¹•ï¼Œé€‰æ‹©ç›˜é¢ä¸é›·æ•°ï¼ˆç®€æ´ä¸”å®é™…å¯ç©ï¼‰
      function pickLayout(){
        const portrait = window.matchMedia("(orientation: portrait)").matches;
        // iPhone 13 390x844ï¼šçºµå‘ä½¿ç”¨ 16x10ï¼Œæ¨ªå‘ 12x18
        return portrait
          ? { rows: 16, cols: 10, mines: 20 }
          : { rows: 12, cols: 18, mines: 40 };
      }

      // çŠ¶æ€
      let R,C,M;                 // è¡Œã€åˆ—ã€é›·
      let firstClick = true;
      let grid=[], revealed=[], flagged=[], nums=[];
      let gameOver=false, win=false;
      let startAt=null, timerId=null, minesLeft=0;

      function idx(r,c){ return r*C + c }
      function inb(r,c){ return r>=0 && r<R && c>=0 && c<C }
      function neighbours(r,c){
        const res=[];
        for(let dr=-1; dr<=1; dr++)
          for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const nr=r+dr, nc=c+dc;
            if(inb(nr,nc)) res.push([nr,nc]);
          }
        return res;
      }

      function reset(){
        ({rows:R, cols:C, mines:M} = pickLayout());
        firstClick=true; gameOver=false; win=false;
        startAt=null; clearInterval(timerId); elTimer.textContent="00:00";
        minesLeft=M; updateMineLeft();
        grid = new Array(R*C).fill(0); // 1=mine
        revealed = new Array(R*C).fill(false);
        flagged  = new Array(R*C).fill(false);
        nums = new Array(R*C).fill(0);
        elStatus.textContent="å‡†å¤‡";
        // æ¸²æŸ“æ£‹ç›˜
        elBoard.style.gridTemplateColumns = `repeat(${C}, 1fr)`;
        elBoard.innerHTML="";
        for(let r=0;r<R;r++){
          for(let c=0;c<C;c++){
            const cell = document.createElement('button');
            cell.className="cell hidden";
            cell.setAttribute('data-r', r);
            cell.setAttribute('data-c', c);
            cell.setAttribute('aria-label', 'æœªç¿»å¼€');
            cell.addEventListener('click', onClick, {passive:false});
            cell.addEventListener('contextmenu', e=>e.preventDefault());
            setupTouchHandlers(cell);
            elBoard.appendChild(cell);
          }
        }
        // æ ¹æ®å®¹å™¨é«˜åº¦è°ƒæ•´ cell å­—å·ï¼ˆæ›´ç¨³ï¼‰
        fitFont();
      }

      function fitFont(){
        // ç²—ç•¥æŒ‰å®¹å™¨é«˜åº¦/è¡Œæ•°ä¼°ä¸€ä»½å­—å·ï¼Œå†™å…¥ CSS å˜é‡ --cell-font
        const rect = elBoard.getBoundingClientRect();
        const gap = parseFloat(getComputedStyle(elBoard).gap||'6');
        const cellSize = Math.floor((rect.height - gap*(R-1)) / R);
        const px = Math.max(12, Math.min(24, Math.floor(cellSize*0.55)));
        document.documentElement.style.setProperty('--cell-font', px + 'px');
      }

      // æ”¾ç½®åœ°é›·ï¼Œä¿è¯é¦–å‡»ä¸æ­»
      function placeMines(safeR, safeC){
        let left=M;
        while(left>0){
          const r = Math.floor(Math.random()*R);
          const c = Math.floor(Math.random()*C);
          if(grid[idx(r,c)]===1) continue;
          // é¿å…é¦–å‡» 3x3 åŒºåŸŸ
          if(Math.abs(r-safeR)<=1 && Math.abs(c-safeC)<=1) continue;
          grid[idx(r,c)] = 1;
          left--;
        }
        // è®¡ç®—æ•°å­—
        for(let r=0;r<R;r++){
          for(let c=0;c<C;c++){
            const i = idx(r,c);
            if(grid[i]===1){ nums[i]=-1; continue; }
            let n=0;
            for(const [nr,nc] of neighbours(r,c)) if(grid[idx(nr,nc)]===1) n++;
            nums[i]=n;
          }
        }
      }

      function startTimer(){
        if(timerId) return;
        startAt = Date.now();
        timerId = setInterval(()=>{
          const s = Math.floor((Date.now()-startAt)/1000);
          const mm = String(Math.floor(s/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          elTimer.textContent = `${mm}:${ss}`;
        }, 250);
      }

      function updateMineLeft(){
        elMine.textContent = String(minesLeft).padStart(2,'0');
      }

      function reveal(r,c){
        if(gameOver) return;
        const i = idx(r,c);
        if(flagged[i] || revealed[i]) return;

        if(firstClick){
          placeMines(r,c);
          firstClick=false;
          elStatus.textContent="è¿›è¡Œä¸­";
          startTimer();
        }

        if(grid[i]===1){
          // è¸©é›·
          revealed[i]=true;
          renderCell(r,c);
          lose();
          return;
        }
        // BFS ç¿»ç©º
        const q=[[r,c]];
        while(q.length){
          const [cr,cc]=q.shift();
          const ci=idx(cr,cc);
          if(revealed[ci] || flagged[ci]) continue;
          revealed[ci]=true;
          if(nums[ci]===0){
            for(const [nr,nc] of neighbours(cr,cc)){
              const ni=idx(nr,nc);
              if(!revealed[ni] && !flagged[ni]) q.push([nr,nc]);
            }
          }
        }
        renderRegion();
        checkWin();
      }

      function toggleFlag(r,c){
        if(gameOver) return;
        const i=idx(r,c);
        if(revealed[i]) return;
        if(firstClick){
          // é¦–æ¬¡æ“ä½œå¦‚æœæ˜¯é•¿æŒ‰ï¼Œä¹Ÿå…ˆå¸ƒé›·å¹¶å¯åŠ¨
          placeMines(r,c);
          firstClick=false;
          elStatus.textContent="è¿›è¡Œä¸­";
          startTimer();
        }
        flagged[i]=!flagged[i];
        minesLeft += flagged[i] ? -1 : 1;
        updateMineLeft();
        renderCell(r,c);
        checkWin();
      }

      function chordOpen(r,c){
        // å·²ç¿»å¼€çš„æ•°å­—æ ¼ï¼Œè‹¥å‘¨å›´æ——æ•°==æ•°å­—ï¼Œåˆ™è‡ªåŠ¨ç¿»å¼€å…¶ä»–æœªç¿»æ ¼
        const i = idx(r,c);
        if(!revealed[i] || nums[i]<=0) return;
        const neigh = neighbours(r,c);
        const flags = neigh.filter(([nr,nc])=>flagged[idx(nr,nc)]).length;
        if(flags !== nums[i]) return;
        for(const [nr,nc] of neigh){
          if(!flagged[idx(nr,nc)] && !revealed[idx(nr,nc)]){
            reveal(nr,nc);
          }
        }
      }

      function lose(){
        gameOver=true; win=false; clearInterval(timerId);
        elStatus.textContent="è¸©é›·";
        // å…¨éƒ¨ç¿»å¼€åœ°é›·
        for(let r=0;r<R;r++) for(let c=0;c<C;c++){
          const i=idx(r,c);
          if(grid[i]===1){ revealed[i]=true; }
        }
        renderRegion();
      }
      function checkWin(){
        if(gameOver) return;
        // èƒœåˆ©æ¡ä»¶ï¼šæ‰€æœ‰éé›·æ ¼å·²ç¿»å¼€
        let opened=0;
        for(let i=0;i<R*C;i++){
          if(revealed[i]) opened++;
        }
        if(opened === R*C - M){
          gameOver=true; win=true; clearInterval(timerId);
          elStatus.textContent="é€šå…³";
          // è‡ªåŠ¨æŠŠå‰©ä½™æ ¼æ ‡æ——
          for(let i=0;i<R*C;i++){
            if(!revealed[i] && !flagged[i]){ flagged[i]=true; minesLeft--; }
          }
          updateMineLeft();
          renderRegion();
        }
      }

      function renderCell(r,c){
        const i=idx(r,c);
        const cell = elBoard.children[i];
        cell.className = 'cell';
        if(!revealed[i]) cell.classList.add('hidden');
        if(flagged[i]) cell.classList.add('flag');
        if(revealed[i] && grid[i]===1) cell.classList.add('mine','revealed');
        if(revealed[i] && grid[i]!==1){
          cell.classList.add('revealed');
          const n = nums[i];
          cell.textContent = n>0 ? n : '';
          if(n>0) cell.classList.add('num'+n);
        }else{
          if(grid[i]!==1) cell.textContent='';
        }
      }
      function renderRegion(){
        for(let r=0;r<R;r++) for(let c=0;c<C;c++) renderCell(r,c);
      }

      // ç‚¹å‡»/è§¦æ‘¸ï¼šçŸ­æŒ‰ç¿»å¼€ï¼Œé•¿æŒ‰ï¼ˆâ‰¥350msï¼‰æ’æ——ï¼›å·²ç¿»æ•°å­—ä¸Šç‚¹æŒ‰å°è¯•â€œå¿«é€Ÿå¼€ç©ºâ€
      function onClick(e){
        e.preventDefault();
        const cell=e.currentTarget;
        const r=+cell.dataset.r, c=+cell.dataset.c;
        const i=idx(r,c);
        if(revealed[i] && nums[i]>0){ chordOpen(r,c); return; }
        reveal(r,c);
      }

      function setupTouchHandlers(cell){
        let pressTimer=null, moved=false;
        const start = (e)=>{
          moved=false;
          e.preventDefault();
          pressTimer = setTimeout(()=>{
            const r=+cell.dataset.r, c=+cell.dataset.c;
            toggleFlag(r,c);
            pressTimer=null;
          }, 350); // é•¿æŒ‰é˜ˆå€¼
        };
        const move = ()=>{
          // å‘ç”Ÿæ»‘åŠ¨åˆ™å–æ¶ˆé•¿æŒ‰
          moved=true;
          if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; }
        };
        const end = (e)=>{
          e.preventDefault();
          if(pressTimer){
            clearTimeout(pressTimer); pressTimer=null;
            if(!moved) cell.click(); // è§¦å‘çŸ­æŒ‰=ç¿»å¼€
          }
        };
        cell.addEventListener('touchstart', start, {passive:false});
        cell.addEventListener('touchmove', move, {passive:false});
        cell.addEventListener('touchend', end, {passive:false});
        cell.addEventListener('touchcancel', end, {passive:false});
      }

      // é‡å¼€ã€æ—‹è½¬/å°ºå¯¸å˜åŒ–æ—¶è‡ªé€‚åº”
      btnRestart.addEventListener('click', reset);
      window.addEventListener('resize', ()=>{
        const oldR=R, oldC=C;
        const layout = pickLayout();
        if(layout.rows!==oldR || layout.cols!==oldC){
          // æ–¹å‘/å°ºå¯¸å˜åŒ–è¾ƒå¤§ï¼šç›´æ¥é‡å¼€
          reset();
        }else{
          // ä»…å­—å·é‡ç®—ï¼Œé¿å…è·³å±€
          setTimeout(fitFont, 50);
        }
      }, {passive:true});

      // åˆå§‹åŒ–
      reset();
    })();
  </script>
</body>
</html>
